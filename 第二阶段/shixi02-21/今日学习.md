## *从输入url到看到页面，中间发生什么*

## *基础概念*

Process 进程。打开一个程序就相当于打开一个进程

Thread 线程。 每个程序有好多线程。

Stack 栈内存  提供了一个环境

## *过程*

在客户端输入一个url经过dns解析，tcp和http的四次握手等等操作传递给服务端，服务端找到源代码response响应给客户端(http状态吗 304缓存 http报文)

客户端   拿到代码，浏览器在内存条中开辟出一段栈内存，给代码执行提供环境，同时分配一个主线程去一行行解析和执行。  进栈执行   	->         <!DOCTYPE>  	 ->  	执行完出栈

当浏览器遇到link/img/script等请求后，都会变成全新的线程去加载资源文件

Task Queue任务队列，也是一个空间 

Event Loop事件循环

（微任务和宏任务）

主线程 自上往下走完后  只生成dom树

CSS处理完成生成CSSOM

———> 生成DOM树和CSSOM  会生成 Render Tree 渲染树

### 延伸

js是单线程的，因为执行代码的只有一个，所有的线程都是浏览器额外分的，浏览器是多线程程序，但是只分配了一个线程来执行页面的代码

## *Dom的重绘和回流*

重绘: 元素样式的改变(宽高，大小，位置等不变)

回流: 元素的大小和位置发生变化

## *尽量减少*

### 分离读写

浏览器有一个渲染队列（可以批量渲染 比如看到有一个引发回流样式的操作，会缓缓看看下方是否还有引发回流的操作，如果有再往下看…...最后批量渲染出来，但是如果中间有console这样读的就会多回流）

### 批量操作

将要修改的样式放在一个class里边，然后一并操作

### 缓存处理

将读的操作缓存起来

```js
// 缓存处理

//这样 是 写的时候又有一次读的操作 会重新回流多次

box.style.height = box.clientHeight + 10 + 'px'
box.style.width = box.clientWidth + 10 + 'px'

// 可以这样改进
// 这样将width的值缓存起来，调用width就不会引发回流了
var width = box.clientWidth
```

### 批量修改

```js
document.cerateDocumentFragment
```

